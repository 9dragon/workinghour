# 项目工时统计WEB软件概要架构设计说明书

## 一、基本信息

|字段名称|内容|
|---|---|
|文档版本|V1.3.0|
|文档作者|全栈软件开发工程师|
|创建日期|[当前日期]|
|适用范围|项目工时统计WEB软件的架构设计、技术选型指导、AI生成代码落地|
|关联文档|《项目工时统计WEB软件需求说明书（V1.2.0）》|

## 二、架构概述

### 2.1 架构设计目标

- 简单轻量：采用极简架构模式，减少不必要的中间件依赖，降低系统复杂度和部署成本。

- 适配AI生成：技术选型优先考虑社区成熟、文档丰富、AI支持度高的技术栈，确保后续AI生成代码可直接复用或少量调整即可落地。

- 高效稳定：满足核心业务（Excel导入、工时查询、工时核对）的性能需求，支持少量并发用户（≤50人）的稳定访问。

- 易维护性：架构分层清晰，模块职责明确，便于后续功能迭代和问题排查。

### 2.2 核心架构模式

采用"前后端分离+轻量服务端+文件存储"的极简架构模式，摒弃复杂的微服务、消息队列等组件，核心分为前端展示层、后端服务层、数据存储层三层，各层职责单一，通过简单接口交互。

```mermaid
graph TD
    A[用户] -->|HTTP/HTTPS| B[前端展示层]
    B -->|RESTful API| C[后端服务层]
    C --> D[数据存储层]
    C --> E[临时文件存储]
```
说明：用户通过浏览器访问前端页面，前端通过RESTful API与后端交互；后端负责业务逻辑处理（Excel解析、数据校验、查询处理、工时核对等），并与数据库交互完成数据持久化；临时文件存储用于存放用户上传的Excel文件和导出的报告文件，处理完成后可自动清理或保留指定周期。

### 2.3 架构核心约束

- 技术栈约束：仅选用开源、轻量、AI友好的技术，不引入付费组件或复杂中间件。

- 部署约束：支持单机部署，无需分布式环境，降低部署和运维成本。

- 性能约束：满足页面加载≤2秒、Excel导入（1000行）≤30秒、查询响应≤5秒、工时核对（100人、全量数据）≤10秒的需求。

## 三、技术选型

### 3.1 前端技术选型

|技术类别|选型方案|选型理由|AI适配性|
|---|---|---|---|
|核心框架|Vue.js 3 + Vite|1. 轻量高效，学习成本低，社区生态成熟；2. Vue 3的Composition API便于模块化开发；3. Vite构建速度快，支持热更新，提升开发效率；4. 无需复杂的状态管理，用Pinia（轻量状态管理库）即可满足简单状态共享需求。|极高：AI对Vue 3语法、组件开发、API调用的生成支持成熟，可直接生成页面组件和交互逻辑。|
|UI组件库|Element Plus|1. 轻量、易用，组件丰富（表格、表单、上传、弹窗等核心组件全覆盖）；2. 与Vue 3完美适配，文档清晰；3. 支持按需引入，减少打包体积。|极高：AI可直接生成基于Element Plus的表格展示、文件上传、条件查询等常用功能代码。|
|HTTP请求|Axios|1. 轻量可靠，支持Promise，便于处理异步请求；2. 拦截器功能可轻松实现请求头添加、响应处理、错误捕获。|极高：AI可直接生成Axios的请求封装、API调用代码。|

### 3.2 后端技术选型

|技术类别|选型方案|选型理由|AI适配性|
|---|---|---|
|核心框架|Python + Flask|1. 轻量高效，学习成本低，开发速度快；2. Flask框架极简，无过多冗余功能，适合小型Web服务；3. Python生态丰富，Excel处理、数据校验等组件成熟；4. 社区文档完善，部署简单，支持单机快速落地。|极高：AI对Flask的路由配置、请求处理、数据库交互逻辑的生成支持完善，可直接生成核心业务接口代码。|
|Excel处理|pandas + openpyxl/xlsxwriter|1. pandas处理表格数据高效，支持复杂数据筛选和格式校验；2. openpyxl/xlsxwriter分别适配.xlsx文件的读取和写入，覆盖Excel全格式需求；3. 组合使用生态成熟，文档丰富，问题排查成本低。|极高：AI可生成基于pandas的Excel解析、数据校验、报告生成代码，适配各类Excel处理场景。|
|数据校验|pydantic|1. 轻量强大，语法简洁，支持类型注解式校验规则定义；2. 支持字段类型、必填项、取值范围、自定义校验等多种场景，完美匹配Excel导入数据的校验需求；3. 与Python生态适配性好，易于集成。|极高：AI可根据需求快速生成pydantic的数据模型和校验规则配置代码。|
|身份认证|PyJWT|1. 轻量无状态，无需存储会话信息，减少数据库压力；2. 生成和验证逻辑简单，与Flask框架集成便捷；3. 支持过期时间设置和签名加密，保障接口安全性。|极高：AI可直接生成PyJWT的签发、验证、请求拦截器配置代码。|

### 3.3 数据存储选型

|存储类别|选型方案|选型理由|AI适配性|
|---|---|---|---|
|关系型数据库|SQLite 3|1. 极简轻量，无需单独部署服务，以文件形式存储，单机部署无压力；2. 支持标准SQL语法，满足项目的结构化数据存储和查询需求；3. 零配置，开箱即用，适合小型应用；4. 支持事务，保障数据一致性。|极高：AI可直接生成SQLite的表结构创建语句、数据增删改查SQL语句。|
|临时文件存储|本地文件系统|1. 无需额外组件，直接使用服务器本地文件系统存储上传的Excel文件和导出的报告文件；2. 配置简单，可通过代码控制文件保留周期（如保留7天），定期自动清理，避免占用过多空间。|极高：AI可生成文件上传、存储路径配置、文件读写、自动清理的代码。|
说明：若后续用户量或数据量增长，可无缝迁移至MySQL（同属关系型数据库，SQL语法兼容），迁移成本极低；当前选型优先保障"简单轻量"和"AI生成适配性"。

## 四、核心模块划分与职责

### 4.1 前端模块划分

|模块名称|核心职责|核心技术/组件|
|---|---|---|
|登录模块|1. 用户名/密码输入与提交；2. 登录状态存储（localStorage）；3. 未登录拦截与跳转。|Vue 3、Element Plus（表单组件）、Axios、JWT|
|数据管理模块|1. Excel文件上传；2. 导入进度展示；3. 导入报告查看与下载；4. 导入记录查询；5. 按批次号查看导入数据详情。|Element Plus（上传组件、表格组件）、Axios|
|工时查询模块|1. 查询维度切换（项目/组织）；2. 筛选条件表单（项目名称、部门、时间范围等）；3. 查询结果表格展示；4. 结果汇总展示；5. 查询结果导出。|Element Plus（表格、表单、下拉框）、Axios|
|工时核对模块|1. 核对类型选择（完整性/合规性）；2. 核对参数设置（时间范围、部门、人员、合规规则）；3. 核对结果表格展示；4. 汇总统计展示；5. 核对报告导出；6. 核对历史记录查看。|Element Plus（表格、表单、下拉框）、Axios|
|系统设置模块|1. 数据备份（生成SQL文件下载）；2. 数据恢复（上传备份文件）；3. 基础配置查看（如文件保留周期、核对规则配置）。|Element Plus（按钮、上传组件）、Axios|
|公共组件模块|1. 全局导航栏；2. 页面布局容器；3. 消息提示（成功/失败/加载中）；4. 通用弹窗。|Vue 3、Element Plus（Layout、Message、Dialog）|

### 4.2 后端模块划分

|模块名称|核心职责|核心技术/组件|
|---|---|---|
|路由模块|1. 统一路由配置；2. 接口权限拦截（未登录校验）；3. 请求参数初步解析。|Flask、PyJWT、Flask-Router|
|用户认证模块|1. 用户名/密码校验；2. JWT签发与验证。|PyJWT、bcrypt（密码加密）、SQLite 3|
|Excel处理模块|1. 文件上传接收与存储；2. Excel文件解析（两层表头识别）；3. 数据拆分（按4种工时类型拆分为多条记录）；4. 数据校验（格式、字段、状态筛选、唯一性）；5. 导入报告生成；6. 有效数据入库。|Flask-Uploads、pandas、openpyxl、pydantic|
|工时查询模块|1. 接收查询条件（维度、筛选参数）；2. 生成查询SQL；3. 数据查询与汇总计算；4. 查询结果格式化；5. 导出文件生成。|SQLite 3、pandas、xlsxwriter|
|工时核对模块|1. 周报提交完整性检查（时间空缺检查、时间重复检查，自动排除周末和节假日）；2. 工作时长一致性检查（按序号聚合4种工时类型+请假时长，对比法定工作时间）；3. 核对报告生成；4. 核对结果记录入库。|SQLite 3、pandas、xlsxwriter|
|节假日管理模块|1. 节假日数据管理（增删改查）；2. 工作日计算（排除周末和节假日，支持调休工作日）；3. 法定工作时间计算；4. 节假日批量导入。|SQLite 3、Python datetime|
|数据存储模块|1. 数据库连接管理；2. 数据增删改查封装；3. 事务控制；4. 数据备份与恢复。|SQLite 3、Flask-SQLAlchemy（ORM可选）|
|公共工具模块|1. 日期时间格式化；2. 错误处理与日志记录；3. 文件清理（定期删除临时文件）；4. 通用常量定义（如标准工作时长8小时/天）。|Python datetime、logging、os模块|

## 五、核心数据模型设计

基于SQLite设计核心数据表，表结构简洁，字段与需求说明书中的核心数据字段对应，确保数据存储完整且无冗余。

### 5.1 核心数据表：工时数据表（work_hour_data）

**Excel数据结构说明：**

钉钉导出的Excel文件采用**两层表头**设计，一个序号（一个工单）可能包含多种工时类型。系统导入时，将一条Excel记录拆分为多条数据库记录（每条记录对应一种工时类型）。

**工时类型分类：**

| 工时类型 | 枚举值 | 工作时长字段 | 加班时长字段 | 请假时长字段 | 项目名称字段 | 说明 |
|---------|-------|------------|------------|------------|------------|------|
| **项目交付** | project_delivery | 项目交付-工作时长 | 项目交付-加班时长 | - | 项目交付-项目名称 | 外部项目交付工时 |
| **产研项目** | product_research | 产品-工作时长 | 产品-加班时长 | - | 产品-项目名称 | 内部产品研发工时 |
| **售前支持** | presales_support | 售前-工作时长 | 售前-加班时长 | - | 售前-项目名称 | 售前支持活动工时 |
| **部门内务** | dept_internal | 部门-工作时长 | 部门-加班时长 | - | 部门-项目名称 | 部门内部管理工时 |
| **请假** | leave | - | - | 请假时长 | NULL | 请假记录（年假/事假/病假等）|

**数据表结构：**

|字段名|字段类型|是否主键|是否非空|字段说明|关联需求字段|
|---|---|---|---|---|---|
|id|INTEGER|是|是|自增主键，唯一标识一条工时数据|-|
|serial_no|TEXT|否|否|钉钉OA审批记录序号|序号|
|user_name|TEXT|否|是|提交OA审批的人员姓名|姓名|
|start_time|DATETIME|否|是|工作开始时间|开始时间|
|end_time|DATETIME|否|是|工作结束时间|结束时间|
|**work_type**|**TEXT**|**否**|**是**|**工时类型（project_delivery/product_research/presales_support/dept_internal/leave）**|**工作类型分类**|
|project_manager|TEXT|否|否|项目经理姓名（根据work_type对应不同字段）|各类型-项目经理|
|project_name|TEXT|否|是|工作所属项目名称（请假记录可为NULL）|各类型-项目名称|
|work_hours|REAL|否|是|实际工作时长（小时），支持1位小数（请假记录为0）|各类型-工作时长|
|overtime_hours|REAL|否|否|加班时长（小时），支持1位小数（请假记录为0）|各类型-加班时长|
|**leave_hours**|**REAL**|**否**|**否**|**请假时长（小时），支持1位小数（仅请假记录有值）**|**请假时长**|
|work_content|TEXT|否|否|具体工作内容描述（最大500字符）|各类型-工作内容|
|approval_result|TEXT|否|是|OA审批结果（仅存储"通过"）|审批结果|
|approval_status|TEXT|否|是|OA审批状态（仅存储"已完成"）|审批状态|
|dept_name|TEXT|否|是|提交OA审批人员所属部门|创建人部门|
|import_batch_no|TEXT|否|是|导入批次号，关联导入记录|-|
|import_time|DATETIME|否|是|数据导入系统的时间|-|

**索引设计**：
- `idx_start_time`：索引字段start_time，用于工时核对中按日期范围快速查询
- `idx_user_name`：索引字段user_name，用于工时核对中按员工查询
- `idx_dept_name`：索引字段dept_name，用于工时核对中按部门查询
- `idx_import_batch_no`：索引字段import_batch_no，用于关联查询导入记录
- `idx_serial_no`：索引字段serial_no，用于按序号聚合工作时长
- `idx_work_type`：索引字段work_type，用于按工时类型筛选和统计

### 5.2 辅助数据表：导入记录表（import_records）

|字段名|字段类型|是否主键|是否非空|字段说明|
|---|---|---|---|---|
|id|INTEGER|是|是|自增主键|
|batch_no|TEXT|否|是|导入批次号（格式：IMP_年月日时分秒_随机数）|
|file_name|TEXT|否|是|上传的Excel文件名|
|total_rows|INTEGER|否|是|上传文件的总数据行数|
|success_rows|INTEGER|否|是|成功导入的有效数据行数|
|repeat_rows|INTEGER|否|是|重复数据行数|
|invalid_rows|INTEGER|否|是|无效数据行数（含状态不符、格式错误等）|
|import_user|TEXT|否|是|执行导入操作的用户名|
|import_time|DATETIME|否|是|导入时间|
|report_path|TEXT|否|否|导入报告文件的存储路径（若有）|
|error_details|TEXT|否|否|错误详情（JSON格式），存储所有无效数据的错误信息|
|duplicate_strategy|TEXT|否|是|重复数据处理策略（skip/cover）|
|file_size|INTEGER|否|否|导入文件大小（字节）|
|created_at|DATETIME|否|是|记录创建时间|

**error_details字段说明：**

- **数据格式**：JSON数组，包含所有无效数据的错误详情
- **存储内容**：
  ```json
  [
    {"row": 3, "field": "项目交付-项目名称", "error": "项目交付-项目名称字段为空"},
    {"row": 5, "field": "审批结果", "error": "审批结果为'--'，仅支持'通过'或'审批通过'"},
    {"row": 8, "field": "项目交付-工作时长", "error": "工作时长超过168小时（一周最大时长）"}
  ]
  ```
- **字段说明**：
  - `row`：Excel文件中的行号（包含表头，从2开始）
  - `field`：出错的字段名称
  - `error`：详细的错误原因描述
- **存储特点**：
  - 支持存储无限制数量的错误记录
  - 使用`json.dumps(errors, ensure_ascii=False)`序列化
  - 兼容Python字符串格式的旧数据（使用`ast.literal_eval`解析）
  - 历史记录可永久保存，方便随时查询和核对

### 5.3 辅助数据表：用户表（sys_users）

|字段名|字段类型|是否主键|是否非空|字段说明|
|---|---|---|---|---|
|id|INTEGER|是|是|自增主键|
|user_name|TEXT|否|是|登录用户名（唯一）|
|password|TEXT|否|是|加密后的密码（bcrypt加密）|
|real_name|TEXT|否|否|用户真实姓名|
|dept_name|TEXT|否|否|用户所属部门|
|create_time|DATETIME|否|是|用户创建时间|

### 5.4 辅助数据表：核对记录表（check_records）

|字段名|字段类型|是否主键|是否非空|字段说明|
|---|---|---|---|---|
|id|INTEGER|是|是|自增主键|
|check_no|TEXT|否|是|核对批次号（格式：CHK_年月日时分秒_随机数）|
|check_type|TEXT|否|是|核对类型（integrity_consistency-周报提交完整性/ work_hours_consistency-工作时长一致性）|
|start_date|DATE|否|是|核对开始日期|
|end_date|DATE|否|是|核对结束日期|
|dept_name|TEXT|否|否|核对部门名称（null表示全部门）|
|user_name|TEXT|否|否|核对人员姓名（null表示全部门人员）|
|check_config|TEXT|否|否|核对规则配置（JSON格式，如节假日数据、标准工作时长等）|
|check_result|TEXT|否|是|核对结果摘要（JSON格式，包含统计数据）|
|report_path|TEXT|否|否|核对报告文件的存储路径（若有）|
|check_user|TEXT|否|是|执行核对操作的用户名|
|check_time|DATETIME|否|是|核对时间|

**核对配置（check_config）JSON结构示例**：

```json
{
  "holidays": ["2026-01-01", "2026-01-02", "2026-01-03"],  // 法定节假日列表
  "workdays": [1, 2, 3, 4, 5],                               // 周一到周五为工作日
  "standard_hours": 8                                         // 每日标准工作时长
}
```

**周报提交完整性核对结果（check_result）JSON结构示例**：

```json
{
  "integrity_check": {
    "total_users": 50,
    "missing_users": 3,
    "total_missing_workdays": 15,
    "duplicate_users": 2,
    "total_duplicate_workdays": 5,
    "integrity_rate": 97.5
  }
}
```

**工作时长一致性核对结果（check_result）JSON结构示例**：

```json
{
  "work_hours_check": {
    "total_serials": 200,
    "normal_serials": 180,
    "short_serials": 12,
    "excess_serials": 8,
    "compliance_rate": 90.0,
    "work_type_stats": {
      "project_delivery": {"total_hours": 3600, "avg_hours": 18.0},
      "product_research": {"total_hours": 1800, "avg_hours": 9.0},
      "presales_support": {"total_hours": 400, "avg_hours": 2.0},
      "dept_internal": {"total_hours": 200, "avg_hours": 1.0}
    }
  }
}
```

**索引设计**：
- `idx_check_type`：索引字段check_type，用于按核对类型查询
- `idx_check_time`：索引字段check_time，用于查询历史核对记录
- `idx_dept_user`：索引字段dept_name + user_name，用于按部门和人员筛选

### 5.5 辅助数据表：节假日表（holidays）

|字段名|字段类型|是否主键|是否非空|字段说明|
|---|---|---|---|---|
|id|INTEGER|是|是|自增主键|
|holiday_date|DATE|否|是|节假日日期|
|holiday_name|TEXT|否|是|节假日名称（如"元旦"、"春节"）|
|is_workday|INTEGER|否|是|是否为调休工作日（0-否/1-是，如春节调休周日上班）|
|year|INTEGER|否|是|年份，用于快速查询|
|created_at|DATETIME|否|是|记录创建时间|

**索引设计**：
- `idx_holiday_date`：唯一索引，避免重复添加同一天
- `idx_year`：索引字段year，用于按年份查询节假日

**业务规则**：
- 默认已包含国家法定节假日数据（2026年起）
- 支持手动添加/删除节假日（如春节前提前放假）
- 支持标记调休工作日（如春节调休周日上班）
- 工作日计算时自动排除周末（除非标记为调休工作日）和法定节假日（除非标记为调休工作日）

## 六、核心业务流程的技术实现

### 6.1 Excel数据导入流程实现

```mermaid
graph TD
    A[前端上传Excel文件] -->|1.通过Axios发送POST请求，携带文件流| B[后端Flask-Uploads接收文件]
    B --> C[存储临时文件到本地目录]
    C --> D[后端pandas+openpyxl解析Excel文件（两层表头识别）]
    D --> E[数据拆分（按4种工时类型拆分：项目交付/产研项目/售前支持/部门内务）]
    E --> F[数据校验与筛选]
    F -->|a.字段完整性校验| G
    F -->|b.字段类型校验（日期/数值/文本）| G
    F -->|c.状态筛选（仅保留审批通过+已完成）| G
    F -->|d.唯一性校验（serial_no+user_name+start_time+work_type，跨批次检测）| G
    G -->|校验通过| H[生成导入批次号]
    H --> I[批量插入有效数据到work_hour_data表（每条记录对应一种工时类型）]
    I --> J[记录导入信息到import_records表]
    J --> K[生成导入报告（含成功/重复/无效行数、错误原因）]
    K --> L[返回导入结果和报告信息给前端]
    G -->|校验失败| M[生成导入报告（标注无效数据行号和原因）]
    M --> L
    L --> N[前端展示导入结果，提供报告查看/下载]
```

### 6.2 工时查询流程实现

```mermaid
graph TD
    A[前端选择查询维度+设置筛选条件] -->|1.通过Axios发送GET请求，携带查询参数| B[后端路由拦截校验登录状态]
    B --> C[解析查询参数（维度、项目名称/部门、时间范围等）]
    C --> D[生成动态SQL查询语句]
    D -->|项目维度| E[查询work_hour_data表，按project_name分组汇总]
    D -->|组织维度| F[查询work_hour_data表，按dept_name分组汇总]
    E --> G
    F --> G[执行SQL查询，获取原始数据和汇总数据]
    G --> H[通过pandas格式化查询结果（日期格式化、数值保留1位小数）]
    H --> I[返回格式化后的结果给前端]
    I --> J[前端通过Element Plus表格展示结果，顶部展示汇总信息]
    J --> K{用户操作}
    K -->|导出结果| L[前端请求后端生成Excel文件，后端通过xlsxwriter生成后返回文件流，前端触发下载]
    K -->|重新查询| A
```

### 6.3 周报提交完整性检查流程实现

```mermaid
graph TD
    A[前端设置核对参数（时间范围/部门/人员）] -->|1.通过Axios发送POST请求，携带核对参数| B[后端路由拦截校验登录状态]
    B --> C[解析核对参数（类型=integrity_consistency）]
    C --> D[查询指定时间范围内的工时数据，按人员分组]
    D --> E[获取节假日数据，排除周末和法定节假日]
    E --> F{执行完整性检查}
    F -->|时间空缺检查| G[检查相邻工单之间是否存在时间空隙]
    G --> H[计算空缺期间的工作日天数（排除周末和节假日）]
    F -->|时间重复检查| I[检查同一员工的工单两两对比时间范围重叠]
    I --> J[计算重叠期间的工作日天数（排除周末和节假日）]
    H --> K[生成空缺检查结果（人员、空缺时间段、影响工作日天数）]
    J --> L[生成重复检查结果（人员、重复工单号、重叠时间段、影响工作日天数）]
    K --> M[统计汇总数据（总人数、空缺人数、重复人数、完整性百分比）]
    L --> M
    M --> N[生成核对批次号，记录核对信息到check_records表]
    N --> O[生成核对报告Excel文件]
    O --> P[返回核对结果和报告信息给前端]
    P --> Q[前端展示核对结果表格和汇总信息]
    Q --> R{用户操作}
    R -->|导出报告| S[触发报告下载]
    R -->|再次核对| A
```

### 6.4 工作时长一致性检查流程实现

```mermaid
graph TD
    A[前端设置核对参数（时间范围/部门/人员）] -->|1.通过Axios发送POST请求，携带核对参数| B[后端路由拦截校验登录状态]
    B --> C[解析核对参数（类型=work_hours_consistency）]
    C --> D[查询指定时间范围内的工时数据]
    D --> E[按序号（serial_no）聚合工作时长，分别统计4种工时类型]
    E --> F[计算工作时长总和（项目交付+产研项目+售前支持+部门内务）]
    F --> G[获取请假时长总和（关联序号）]
    G --> H[计算应工作时長 = 工作时长总和 + 请假时长总和]
    H --> I[计算法定工作时间 = 工作日天数 × 8小时/天（排除周末和节假日）]
    I --> J{一致性判定（无容差）}
    J -->|差异 = 0| K[状态：正常]
    J -->|差异 < 0| L[状态：偏低（时长不足）]
    J -->|差异 > 0| M[状态：偏高（时长超标）]
    K --> N[生成核对结果（序号、人员、时间、各类型时长、差值、状态）]
    L --> N
    M --> N
    N --> O[统计汇总数据（总工单数、正常/偏低/偏高工单数、合规率、分类型统计）]
    O --> P[生成核对批次号，记录核对信息到check_records表]
    P --> Q[生成核对报告Excel文件]
    Q --> R[返回核对结果和报告信息给前端]
    R --> S[前端展示核对结果表格和汇总信息]
    S --> T{用户操作}
    T -->|导出报告| U[触发报告下载]
    T -->|再次核对| A
```

### 6.5 节假日管理流程实现

#### 6.5.1 节假日API同步流程

```mermaid
graph TD
    A[管理员点击API同步按钮，选择年份] -->|1.通过Axios发送POST请求| B[后端路由拦截校验登录状态]
    B --> C[解析同步参数（年份）]
    C --> D[调用第三方API服务（timor.tech）]
    D --> E{API调用成功？}
    E -->|是| F[解析API返回的节假日JSON数据]
    E -->|否| G[返回错误提示（网络超时/API服务不可用）]
    F --> H[删除该年份现有的data_source='api'的节假日数据]
    H --> I[批量插入新的节假日数据]
    I --> J[更新is_weekend字段（标记周末）]
    J --> K[记录同步信息到日志]
    K --> L[返回同步结果统计（总数、成功数）]
    L --> M[前端显示同步成功消息，刷新节假日列表]
    M --> N{用户操作}
    N -->|查看列表| O[前端查询节假日列表，按data_source分组展示]
```

**第三方API集成说明**：

- **API服务**：timor.tech 免费中国节假日API（https://timor.tech/api/holiday/）
- **API接口**：`GET /{year}/` 返回指定年份所有节假日和调休安排
- **数据格式**：
  ```json
  {
    "code": 0,
    "holiday": {
      "2026-01-01": {"holiday": true, "name": "元旦", "wage": 3, "rest": 3},
      "2026-02-10": {"holiday": true, "name": "春节", "wage": 3, "rest": 8}
    }
  }
  ```
- **超时设置**：10秒超时，最多重试3次
- **异常处理**：API失败不影响系统其他功能，系统仍可使用手动录入和周末生成

#### 6.5.2 周末自动生成流程

```mermaid
graph TD
    A[管理员点击生成周末按钮] -->|1.通过Axios发送POST请求| B[后端路由拦截校验登录状态]
    B --> C[解析参数（当前年份）]
    C --> D[计算该年份的所有周六和周日]
    D --> E[删除该年份现有的data_source='auto'的周末数据]
    E --> F[遍历每一天，判断是否为周末]
    F --> G[是周末（周六或周日）]
    F -->|不是周末| H[跳过]
    G --> I[检查该日期是否已存在节假日记录]
    I --> J{是否存在？}
    J -->|是| K[跳过（避免覆盖节假日或调休工作日）]
    J -->|否| L[插入周末记录]
    L --> M[设置字段：is_weekend=1, is_workday=0, data_source='auto']
    M --> N[批量插入周末数据]
    N --> O[返回生成结果统计（总天数、生成数、跳过数）]
    O --> P[前端显示生成成功消息，刷新节假日列表]
```

**周末生成规则**：
- 自动识别：使用Python datetime模块的 weekday() 方法（Monday=0, Sunday=6）
- 周六周日：weekday() >= 5 的日期
- 优先级保护：已存在节假日或调休工作日的日期不会被覆盖
- 数据来源：生成的周末数据标记为 `data_source='auto'`

#### 6.5.3 工作日计算流程

```mermaid
graph TD
    A[核对算法需要计算工作日] --> B[调用WorkdayCalculator.is_workday日期]
    B --> C{查询数据库是否有该日期记录}
    C -->|有记录| D[返回数据库is_workday字段值]
    C -->|无记录| E[判断是否为周末]
    E -->|是周末| F[返回false（非工作日）]
    E -->|不是周末| G[返回true（工作日）]
    D --> H{is_workday == 1?}
    H -->|是| G[返回true（调休工作日）]
    H -->|否| F[返回false（节假日）]
    G --> I[返回判断结果]
    F --> I
```

**工作日计算优先级规则**：

| 优先级 | 数据来源 | 判断规则 | 示例 |
|--------|----------|----------|------|
| 1 | 数据库特殊标记 | 查询holidays表，使用is_workday字段 | 调休工作日（is_workday=1）、节假日（is_workday=0） |
| 2 | 周末默认规则 | Python datetime.weekday()判断 | 周六周日为非工作日，周一到周五为工作日 |

**工作日计算接口**：

- **输入**：开始日期、结束日期
- **输出**：
  ```python
  {
    "totalDays": 31,           # 总天数
    "workdays": 22,           # 工作日天数
    "weekendDays": 8,          # 周末天数
    "holidays": 1,             # 节假日天数
    "workdayDates": [...]       # 工作日日期列表
  }
  ```

#### 6.5.4 节假日数据管理流程

```mermaid
graph TD
    A[管理员操作节假日数据] --> B{操作类型}
    B -->|查询列表| C[按年份、数据来源筛选，分页展示]
    B -->|添加节假日| D[手动添加单个节假日]
    B -->|删除节假日| E[删除指定节假日记录]
    B -->|API同步| F[从第三方API同步节假日]
    B -->|生成周末| G[自动生成当前年份周末]

    D --> H[输入日期、名称、是否调休]
    H --> I[检查日期是否已存在]
    I -->|已存在| J[返回错误提示]
    I -->|不存在| K[插入数据库，data_source='manual']

    E --> L[删除节假日记录]
    L --> M[返回删除成功]

    F --> N[调用timor.tech API]
    N --> O[解析并批量插入，data_source='api']

    G --> P[识别并标记所有周六周日]
    P --> Q[批量插入，data_source='auto']

    C --> R[返回节假日列表，含data_source和is_weekend字段]
    K --> R
    M --> R
    O --> R
    Q --> R
```

**数据来源标识**（data_source字段）：

| 来源值 | 标签颜色 | 说明 | 覆盖策略 |
|--------|----------|------|----------|
| `manual` | 蓝色 | 管理员手动录入 | 不被自动同步覆盖 |
| `api` | 绿色 | 第三方API同步 | 年度同步时覆盖同来源数据 |
| `auto` | 灰色 | 系统自动生成周末 | 年度生成时覆盖同来源数据 |

**节假日管理API接口清单**：

| 接口路径 | 方法 | 说明 | 新增/修改 |
|---------|------|------|----------|
| `/holidays` | GET | 查询节假日列表（支持年份、来源筛选，分页） | 修改 |
| `/holidays` | POST | 添加节假日（手动录入） | 保留 |
| `/holidays/<id>` | DELETE | 删除节假日 | 保留 |
| `/holidays/batch` | POST | 批量导入节假日（JSON格式） | 保留 |
| **`/holidays/sync/<year>`** | **POST** | **从第三方API同步指定年份节假日** | **新增** |
| **`/holidays/generate-weekends/<year>`** | **POST** | **生成指定年份周末数据** | **新增** |
| **`/holidays/calculate-workdays`** | **POST** | **计算日期范围内的工作日** | **新增** |

## 七、部署与运维设计

### 7.1 部署架构

采用单机部署架构，无需分布式环境，部署步骤极简：

1. 准备一台服务器（Windows/Linux/macOS均可），安装Python环境（v3.9+）。

2. 将前端打包后的静态文件（dist目录）和后端代码部署到服务器指定目录。

3. 后端通过Gunicorn（轻量WSGI服务器）启动Flask服务，可搭配supervisor守护进程。

4. 前端静态文件可通过Nginx托管（推荐，提升静态资源访问速度），或通过Flask内置静态文件服务托管（简化部署）。

5. SQLite数据库文件自动生成在后端代码目录下，无需单独配置。

6. 配置系统定时任务（如cron），定期清理临时文件（如每天凌晨清理超过7天的文件）。

### 7.2 运维要点

- 临时文件清理：后端定时任务（如每天凌晨）清理本地临时目录中超过7天的Excel文件、导入报告、核对报告，避免占用过多磁盘空间。

- 数据备份：用户可通过系统"数据备份"功能手动导出SQLite数据库文件（.db），建议定期（如每周）备份并下载到本地。

- 日志管理：后端记录简单操作日志（登录、导入、查询、核对）和错误日志，存储在本地日志文件中，保留30天，便于问题排查。

- 版本更新：后续迭代时，直接覆盖后端代码和前端静态文件，SQLite数据库表结构变更可通过SQL脚本执行，无需复杂迁移工具。

- 核对规则维护：核对规则（如工作日定义、合规阈值）存储在配置文件或数据库配置表中，支持管理员通过系统界面调整，无需修改代码。

## 八、AI生成代码适配说明

### 8.1 代码生成优先级

1. 基础环境搭建：前端Vue 3+Vite项目初始化、后端Flask项目初始化、数据库表结构创建（包括work_hour_data表的work_type字段更新）。

2. 核心业务模块：Excel导入模块（包含4种工时类型拆分逻辑）、工时查询模块、工时核对模块（周报提交完整性检查、工作时长一致性检查）、登录认证模块。

3. 节假日管理模块：节假日表（holidays）创建、节假日数据管理接口、工作日计算函数（排除周末和节假日）。

4. 辅助功能模块：导入记录查看、核对记录查看、查询结果导出、数据备份与恢复。

5. 公共工具模块：日志记录、临时文件清理、数据格式化、工作日计算工具函数。

### 8.2 AI生成代码的复用建议

- 前端组件：直接复用AI生成的Element Plus表格、表单、上传组件代码，仅需调整组件名称和接口地址。工时核对模块可复用工时查询模块的筛选表单和表格展示组件结构。

- 后端接口：复用AI生成的Flask路由、请求处理、数据库操作代码，重点核对数据校验规则、核对算法逻辑和SQL语句。

- 数据库操作：复用AI生成的SQL建表语句和CRUD代码，确保字段类型和约束与设计一致。工时核对涉及复杂的分组查询和日期范围查询，需AI重点关注SQL性能优化。

- 配置文件：AI生成的配置代码（如文件存储路径、JWT密钥、日志路径、核对规则默认值）需根据实际部署环境调整。

### 8.3 潜在问题与解决方法

- Excel解析兼容性：若AI生成的xlsx代码存在格式兼容问题，可补充指定Excel文件格式（.xls/.xlsx），让AI优化解析逻辑。**特别需要注意两层表头的正确解析和工时类型拆分逻辑**。

- 工时类型拆分错误：若AI生成的代码未正确处理4种工时类型的拆分（项目交付、产研项目、售前支持、部门内务），需明确说明Excel两层表头结构，并提供具体的拆分规则和示例数据，让AI修正拆分逻辑。

- 节假日处理不准确：若工作日计算未正确排除节假日，需提供节假日数据结构和计算规则，让AI修正工作日计算函数。**重要：必须先查询holidays表获取节假日数据，再计算工作日**。

- 数据校验规则遗漏：若AI生成的校验代码未覆盖全部需求，可将需求中的校验规则逐条列出，让AI补充完善pydantic校验配置。

- SQL查询性能：若数据量较大时查询较慢（尤其是工时核对涉及大量数据扫描和按序号聚合），可让AI生成索引创建语句（为serial_no、work_type、start_time、user_name、dept_name等字段创建索引），并优化SQL查询语句。

- 工时核对算法准确性：若AI生成的核对算法存在问题（如工作日计算错误、空缺/重复判断逻辑错误、时长一致性判定错误），可提供具体的测试场景和预期结果，让AI修正算法逻辑。**重要：工作时长一致性核对必须按序号聚合4种工时类型，且不支持容差**。

## 九、附录

### 9.1 技术栈版本建议

|技术类别|技术名称|建议版本|
|---|---|---|
|前端|Vue.js|3.3.x|
|前端|Vite|4.4.x|
|前端|Element Plus|2.4.x|
|前端|Axios|1.6.x|
|后端|Python|3.9.x 或 3.10.x|
|后端|Flask|2.3.x|
|后端|SQLite|3.41.x|
|后端|PyJWT|2.6.x|
|后端|pandas|2.0.x|
|后端|openpyxl|3.1.x|

### 9.2 核心依赖包清单

后端requirements.txt核心依赖：

```text
flask==2.3.3
flask-uploads==0.2.1
pandas==2.0.3
openpyxl==3.1.2
xlsxwriter==3.1.9
pydantic==2.4.2
pyjwt==2.6.0
bcrypt==4.0.1
flask-sqlalchemy==3.1.1
gunicorn==21.2.0
python-dotenv==1.0.0
pytest==7.4.3
```

前端package.json核心依赖：

```json
{
  "dependencies": {
    "vue": "^3.3.11",
    "pinia": "^2.1.7",
    "element-plus": "^2.4.4",
    "axios": "^1.6.2",
    "dayjs": "^1.11.10"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.5.2",
    "vite": "^4.5.0"
  }
}
```

### 9.3 版本变更记录

|版本号|变更时间|变更内容|变更人|
|---|---|---|---|
|V1.0.0|2026-01-15|初始架构设计，包含Excel导入、工时查询、用户认证等核心功能|全栈软件开发工程师|
|V1.1.0|2026-01-15|新增工时核对模块设计，包括完整性检查和合规性检查；新增核对记录表（check_records）；更新核心业务流程图，增加工时核对流程；更新模块划分和职责；优化数据库索引设计|全栈软件开发工程师|
|V1.2.0|2026-01-15|新增导入数据查看功能设计，支持按批次号查看导入数据详情；更新数据管理模块职责|全栈软件开发工程师|
|V1.3.0|2026-01-23|基于需求V1.2.0重新设计工时核对功能架构；work_hour_data表新增work_type字段支持4种工时类型（项目交付、产研项目、售前支持、部门内务）；新增holidays节假日表；更新Excel导入流程（增加工时类型拆分逻辑）；重新设计工时核对流程（周报提交完整性检查、工作时长一致性检查）；更新check_records表的check_type和check_result字段说明；新增节假日管理模块；更新索引设计（idx_serial_no、idx_work_type）|全栈软件开发工程师|
|V1.3.1|2026-01-23|确认work_hour_data表需要增加leave_hours字段以支持请假记录存储；完善work_type枚举值（增加leave类型）；确保系统能够完整支持4种工时类型+请假的核对和统计需求；更新数据拆分逻辑说明（包含请假记录拆分为独立记录）|全栈软件开发工程师|

> （注：文档部分内容可能由 AI 生成）
